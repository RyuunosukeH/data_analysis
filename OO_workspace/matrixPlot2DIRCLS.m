function [fig,had] = matrixPlot2DIRCLS(dataMatrix,w1,w3,t2_array,dim,CLS,maxMatrixCLS,varargin)
% matrixPlot2DIR(dataMatrix,w1,w3,t2s,dimensions,varargin)
%
% dataMatrix is a (n x m x p) matrix generated by 'prepareGlobalFitData,'
% where the indices correspond to w3, w1, and t2 values respectively (each
% 'p' index represents a new spectrum).
%
% w1 and w3 should be arrays of initial and final frequencies
%
% 'dimensions' is a 1x2 matrix specifying the number of rows and columns in
% the resulting matrix plot.
%
% 'CLS' is the structure returned from the fitCLS function
%
% 'maxMatrixCLS' is the structure returned from the CLSMaxMatrix function
%
% varargin:
%   'displayscans' - scan numbers to display
%   'height_px' - height of the spectra to be plotted in pixels
%   'zlimit' - apply a z-limit (between 0 and 1)
%   'n_contours' - define the number of contours to plot
%   'level' - plot contours up to a defined level
%   'fignum' - the figure number you want the matrix plot to appear in --
%               defaults to 100000

height = 175;
n_contours = 14;
zlimit = 0; 
flag_fixed_level = false;
fignum = 100000;

while length(varargin)>=2 %using a named pair
    arg = varargin{1};
    val = varargin{2};
    switch lower(arg)
        case 'displayscans'
            disp_scans = val;
            dataMatrix = dataMatrix(:,:,disp_scans);
            t2_array = t2_array(disp_scans);
        case 'height_px'
            height = val;
        case 'n_contours'
            n_contours = val;
        case 'zlimit'
            zlimit = val;
        case 'level'
            flag_fixed_level = true;
            zlimit = val;
        case 'fignum'
            fignum = val;
        otherwise
            warning(['unknown option ',arg])
    end
    varargin = varargin(3:end);
end

m = dim(1);
n = dim(2);

[~,~,n_scans] = size(dataMatrix);

fig = figure(fignum);
set(fig,'color','w')
clf
fig.Units = 'pixels';
x_offset1 = 85;
x_offset2 = 50;
y_offset = 75;

w = (range(w1)/range(w3))*height;

map = myMapRGB(n_contours);
set(fig,'pos',[x_offset1 y_offset n*w+x_offset1+x_offset2 m*height+1.5*y_offset]);
count = 0;
had = gobjects(m,n);
for ii = 1:m
    for jj = 1:n
        count = count+1;
        if count > n_scans
            continue
        end
        %data
        had(ii,jj) = axes('units','pixels','position',[x_offset1 + (jj-1)*w, y_offset + (m-1)*height - (ii-1)*height, w, height]);
        xx = w1;
        yy = w3;
        zz = dataMatrix(:,:,count);

        y = maxMatrixCLS(count,:,1)';
        y_std = maxMatrixCLS(count,:,2)';
        % zlimit determines what is what the range is that is covered by the
        % contours. If limit <= 0, the data is used to determine it (old behaviour
        % and default). If zlimit is between 0 and 1, it will use the data as well,
        % but only plots a fraction of it (the number between 0 and 1. If zlimit is
        % large than 1, it will use that value.
        if zlimit <= 0
            [ca, level_list]= myCaxis2(zz, n_contours);
            %ca
        elseif ~flag_fixed_level %zlimit > 0 && zlimit <= 1
            [ca, level_list] = myCaxis2(zz, n_contours);
            ca = ca * zlimit;
            level_list = level_list * zlimit;
        else
            ca = [-zlimit zlimit];
            level_list = linspace(-zlimit, zlimit, n_contours+2);
        end
        contourf(had(ii,jj),xx,yy,zz,level_list);
        hold on
        axis equal
        line([xx(1) xx(end)],[xx(1) xx(end)],'Color',[0 0 0]);
        colormap(map)
        caxis(ca);
        plot(CLS(count).w1, CLS(count).fitresult(CLS(count).w1), 'r','LineWidth',1.5),...
        errorbar(CLS(count).w1,y,y_std,'ro'), hold off;
        hold off
        t2_lab = text(xx(1)+0.1*range(xx),yy(end)-0.05*range(yy),[num2str(t2_array(count)),' ps']); %t2 display
        t2_lab.FontSize = 11;
        t2_lab.FontWeight = 'bold';
        
        if ii == ceil(m/2) && jj == 1
            had(ii,jj).YLabel.String = '\omega_{3}/2{\pi}c (cm^{-1})';
            had(ii,jj).YLabel.FontSize = 10;
        end
        if jj ~= 1
            set(had(ii,jj),'YTick',[])
        end
        if count <= n_scans - n
            set(had(ii,jj),'XTickLabel',[]);
        end
        
        if jj == ceil(n./2) && ii == m
            had(ii,jj).XLabel.String = '\omega_{1}/2{\pi}c (cm^{-1})';
            had(ii,jj).XLabel.FontSize = 10;
        end
    end
end

% ind = zeros(size(had));
for ii = 1:size(had,1)
    for jj = 1:size(had,2)
        ind(ii,jj) = isa(had(ii,jj),'matlab.graphics.axis.Axes');
    end
end
set(had(ind),'Tickdir','out','ticklength',3.*get(gca,'ticklength'),'XTickLabelRotation',45);